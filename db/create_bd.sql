REM -- 																			BASE DE DATOS - MUSIC DDBB		

REM --					 CREACION DE BASE DE DATOS
--CREATE DATABASE Music_life_DDBB ;
-- Comentado de momento
  --connect system/system
  --set serveroutput on
  --set verify off

  --ALTER SESSION SET NLS_DATE_FORMAT='DD/MM/YYYY';

REM --					 BORRADO DE TABLAS

DROP TABLE USUARIO CASCADE CONSTRAINT;
DROP TABLE PLAYLIST CASCADE CONSTRAINT;
DROP TABLE COMENTARIO CASCADE CONSTRAINT;
--DROP TABLE CANCIONES CASCADE CONSTRAINT;
DROP TABLE VALORACION CASCADE CONSTRAINT;

REM --					 CREACION DE TABLAS

REM --	USUARIO
CREATE TABLE USUARIO(
	ID NUMBER(6) CONSTRAINT PK_USUARIO PRIMARY KEY,
	NOMBRE VARCHAR2(26) NOT NULL,
	--NICK_NAME VARCHAR(26) NOT NULL UNIQUE,
	EMAIL VARCHAR2(50) NOT NULL UNIQUE,
	CONTRASENA VARCHAR2(20) NOT NULL
);

REM --  PLAYLIST
CREATE TABLE PLAYLIST(
  ID_PL NUMBER(6) CONSTRAINT PK_PLAYLIST PRIMARY KEY,
  NOMBRE VARCHAR2(26) NOT NULL,
  CREADOR_ID NUMBER(6) NOT NULL,
  CONSTRAINT FK_CREADORID_PLAY FOREIGN KEY (CREADOR_ID) REFERENCES USUARIO(ID) ON DELETE CASCADE,
  --CONSTRAINT FK_CANCIONID_PLAY FOREIGN KEY (CANCION_ID) REFERENCES CANCIONES(CANCION_ID) ON DELETE CASCADE
);

REM --  PLAYLIST DE PRUEBA
CREATE TABLE PLAYLIST_PRUEBA(
  ID_PL NUMBER(6) CONSTRAINT PK_PLAYLIST PRIMARY KEY,
  NOMBRE VARCHAR2(26) NOT NULL,
  CREADOR_ID NUMBER(6) NOT NULL,
  LINK VARCHAR2(20) NOT NULL, --AÑADIR UNIQUE Y LINK AL GLOBAL
  CONSTRAINT FK_CREADORID_PLAY FOREIGN KEY (CREADOR_ID) REFERENCES USUARIO(ID) ON DELETE CASCADE,
  --CONSTRAINT FK_CANCIONID_PLAY FOREIGN KEY (CANCION_ID) REFERENCES CANCIONES(CANCION_ID) ON DELETE CASCADE
);

REM --  COMENTARIO
CREATE TABLE COMENTARIO(
  COMENTARIO_ID NUMBER(6) NOT NULL,
  CADENA_TEXTO VARCHAR2(600) NOT NULL, -- Oracle Database 12c admite hasta 32767 caracteres, anteriores hasta 4000
  FECHA_COMENTARIO DATE,
  USUARIO_ID NUMBER(6) NOT NULL,
  PLAYLIST_ID NUMBER(6) NOT NULL,
  CONSTRAINT FK_USUARIOID_COM FOREIGN KEY (USUARIO_ID) REFERENCES USUARIO(ID) ON DELETE CASCADE,
  CONSTRAINT FK_PLAYLISTID_COM FOREIGN KEY (PLAYLIST_ID) REFERENCES PLAYLIST(ID_PL) ON DELETE CASCADE,
  CONSTRAINT PK_COMENTARIO PRIMARY KEY(COMENTARIO_ID,USUARIO_ID,PLAYLIST_ID)
);

REM --  CANCIONES En principio de eso se encarga la API
--CREATE TABLE CANCIONES(
--   CANCION_ID NUMBER(6) CONSTRAINT PK_CANCION PRIMARY KEY,
--    TITULO VARCHAR(20),
--    ARTISTA VARCHAR(20)
--);

REM --	VALORACION
CREATE TABLE VALORACION(
	VALORACION_ID NUMBER(6) NOT NULL,
	PLAYLIST_ID NUMBER(6) NOT NULL,
	USUARIO_ID NUMBER(6) NOT NULL,
	PUNTUACION NUMBER(2,1) NOT NULL,
	CONSTRAINT FK_PLAYLISTID_VAL FOREIGN KEY (PLAYLIST_ID) REFERENCES PLAYLIST(ID_PL) ON DELETE CASCADE,
	CONSTRAINT FK_USUARIOID_VAL FOREIGN KEY (USUARIO_ID) REFERENCES USUARIO(ID) ON DELETE CASCADE,
	CONSTRAINT PK_VALORACION PRIMARY KEY(VALORACION_ID,PLAYLIST_ID,USUARIO_ID)
);

REM -- 						BORRADO DE FILAS
DELETE USUARIO;
DELETE PLAYLIST;
DELETE COMENTARIO;
--DELETE CANCIONES;
DELETE VALORACION;

REM --					 CREACION DE TRIGGERS

REM -- TRIGGER: INCREMENTAR ID USUARIOS AUTOMATICAMENTE - Tal vez no sea necesario, al menos de momento
CREATE OR REPLACE TRIGGER usuarios_insertados
  BEFORE INSERT ON USUARIO
  FOR EACH ROW
BEGIN
  SELECT usuarios_secuencia.nextval
  INTO :NEW.ID
  FROM dual;
END;
/
CREATE SEQUENCE usuarios_secuencia;



-- CREATE OR REPLACE TRIGGER comentarios_insertados
  -- BEFORE INSERT ON COMENTARIO
  -- FOR EACH ROW
-- BEGIN
  -- SELECT comentarios_secuencia.nextval
  -- INTO :NEW.COMENTARIO_ID
  -- FROM dual;
-- END;
-- /

REM -- TRIGGER: INCREMENTAR ID COMENTARIOS AUTOMATICAMENTE - si no guardamos fecha-hora, sería la manera de poder ordenarlos cronoglógicamente
--CREATE SEQUENCE comentarios_secuencia;


-- Queda por saber cómo va a funcionar la api, en cuanto a cómo afecta a la base de datos las playlists y canciones, las guardamos en nuestra base o nos la da la api?